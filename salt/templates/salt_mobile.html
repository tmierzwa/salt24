<!DOCTYPE html>

{% load staticfiles %}

<meta name="viewport" id="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no;" />

<link rel="shortcut icon" href="{% static 'images/salt-icon.gif' %}" type="image/x-icon">
<link rel="icon" href="{% static 'images/salt-icon.gif' %}" type="image/x-icon">
<link rel="stylesheet" href="http://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.css" />
<link rel="stylesheet" href="{% static 'salt-mobile.css' %}" />
<link rel="stylesheet" href="{% static 'mobile-style.css' %}" />

<script src="http://code.jquery.com/jquery-1.12.0.min.js"></script>
<script src="http://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js"></script>

<link rel="stylesheet" type="text/css" href="{% static 'jquery.datetimepicker.min.css' %}" >
<script src="{% static 'scripts/jquery.datetimepicker.full.min.js' %}"></script>

<script>

    ( function( $ ) {
    function pageIsSelectmenuDialog( page ) {
        var isDialog = false,
            id = page && page.attr( "id" );
        $( ".filterable-select" ).each( function() {
            if ( $( this ).attr( "id" ) + "-dialog" === id ) {
                isDialog = true;
                return false;
            }
        });
        return isDialog;
    }
    $.mobile.document
        // Upon creation of the select menu, we want to make use of the fact that the ID of the
        // listview it generates starts with the ID of the select menu itself, plus the suffix "-menu".
        // We retrieve the listview and insert a search input before it.
        .on( "selectmenucreate", ".filterable-select", function( event ) {
            var input,
                selectmenu = $( event.target ),
                list = $( "#" + selectmenu.attr( "id" ) + "-menu" ),
                form = list.jqmData( "filter-form" );
            // We store the generated form in a variable attached to the popup so we avoid creating a
            // second form/input field when the listview is destroyed/rebuilt during a refresh.
            if ( !form ) {
                input = $( "<input data-type='search'></input>" );
                form = $( "<form></form>" ).append( input );
                input.textinput();
                list
                    .before( form )
                    .jqmData( "filter-form", form ) ;
                form.jqmData( "listview", list );
            }
            // Instantiate a filterable widget on the newly created selectmenu widget and indicate that
            // the generated input form element is to be used for the filtering.
            selectmenu
                .filterable({
                    input: input,
                    children: "> option[value]"
                })
                // Rebuild the custom select menu's list items to reflect the results of the filtering
                // done on the select menu.
                .on( "filterablefilter", function() {
                    selectmenu.selectmenu( "refresh" );
                });
        })
        // The custom select list may show up as either a popup or a dialog, depending on how much
        // vertical room there is on the screen. If it shows up as a dialog, then the form containing
        // the filter input field must be transferred to the dialog so that the user can continue to
        // use it for filtering list items.
        .on( "pagecontainerbeforeshow", function( event, data ) {
            var listview, form;
            // We only handle the appearance of a dialog generated by a filterable selectmenu
            if ( !pageIsSelectmenuDialog( data.toPage ) ) {
                return;
            }
            listview = data.toPage.find( "ul" );
            form = listview.jqmData( "filter-form" );
            // Attach a reference to the listview as a data item to the dialog, because during the
            // pagecontainerhide handler below the selectmenu widget will already have returned the
            // listview to the popup, so we won't be able to find it inside the dialog with a selector.
            data.toPage.jqmData( "listview", listview );
            // Place the form before the listview in the dialog.
            listview.before( form );
        })
        // After the dialog is closed, the form containing the filter input is returned to the popup.
        .on( "pagecontainerhide", function( event, data ) {
            var listview, form;
            // We only handle the disappearance of a dialog generated by a filterable selectmenu
            if ( !pageIsSelectmenuDialog( data.prevPage ) ) {
                return;
            }
            listview = data.prevPage.jqmData( "listview" );
            form = listview.jqmData( "filter-form" );
            // Put the form back in the popup. It goes ahead of the listview.
            listview.before( form );
        });
    })( jQuery );

</script>

<html>

<head>
    <title>{% block title %}SALT{% endblock %}</title>
</head>

<body>
    <div id="page" data-role="page">
        <div data-role="header" data-position="fixed">
            <h1 style="color: #c1272d">{% block header %}Header{% endblock %}</h1>
            <div id="custom-border-radius">
                <a href="{% url 'dispatcher' %}"
                   class="header-button-left ui-btn ui-corner-all ui-btn-inline ui-mini ui-btn-left ui-btn-icon-notext ui-icon-home"></a>
                {% if user.is_authenticated %}
                    <a href="{% url 'logout' %}"
                       class="header-button-right ui-btn ui-corner-all ui-btn-inline ui-mini ui-btn-right ui-btn-icon-notext ui-icon-power"></a>
                {% endif %}
            </div>
        </div>
        <div data-role="main" class="ui-content">
            {% block content %}Page content{% endblock %}
        </div>
      <div data-role="footer" data-position="fixed">
         {% block footer %}
         {% endblock %}
      </div>
    </div>
</body>

</html>